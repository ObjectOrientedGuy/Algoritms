#include <iostream>
#include <gtest/gtest.h>


template<typename T>
struct node{
    int  row;
    int column;
    T value;
    node* next_right;
    node* next_down;

    node(int row, int column, T value, node *nextLeft, node *nextUp) : row(row), column(column), value(value),
                                                                       next_right(nextLeft), next_down(nextUp) {}
};

template<typename T>
class SparseMatrix{
private:
    int rows;
    int columns;
public:
    node<T> *head;
    SparseMatrix(int rows, int columns) : rows(rows), columns(columns) {
            head = new node<T>(0, 0, 0, nullptr, nullptr);
            node<T> *tmp = head;
            for (int i = 1; i < columns; ++i) {
                tmp->next_right = new node<T>(0, i, 0, nullptr, nullptr);
                tmp = tmp->next_right;
            }
            node<T> *tmp1 = head;
            for (int i = 0; i < rows; ++i) {
                tmp1->next_down = new node<T>(i, 0, 0, nullptr, nullptr);
                tmp1 = tmp1->next_down;
            }

    }

    void insertElement(int row,int column,T value){
        if(row>rows||column>columns) exit(-1);
        node<T> *tmp=head;
        for(int i=0;i<row;++i){
            tmp=tmp->next_down;
        }
        for(int i=0;i<column-1;i++){
           if(tmp->next_right== nullptr) break;
           tmp=tmp->next_right;
        }
        node<T> *nextAfterTemporary=tmp->next_right;
        tmp->next_right=new node<T>(row,column,value,nextAfterTemporary, nullptr);
        node<T> *tmp1=head;
        for(int i=0;i<column;++i){
            tmp1=tmp1->next_right;
        }
        for(int i=0;i<row-1;++i){
            if(tmp1->next_down== nullptr)break;
            tmp1=tmp1->next_down;
        }
        node<T> *nextAfterTmp1=tmp1->next_down;
        tmp1->next_down=tmp->next_right;
        (tmp->next_right)->next_down=nextAfterTmp1;
    }

    SparseMatrix* addTwoMatrix(SparseMatrix<T>& left){
        SparseMatrix<T> right=*this;
        auto *returnMatrix=new SparseMatrix<T>(right.rows,right.columns);
        for(int i=0;i<right.rows;++i){
            node<T> *right_head=right.head;
            node<T> *left_head=left.head;
                    for(int k=0;k<i;++k){
                        right_head=right_head->next_down;
                        left_head=left_head->next_down;
                    }

            for(int r=0;r<right.columns;r++){
                if(right_head->next_right== nullptr&&left_head->next_right== nullptr) break;
                else if(right_head->next_right== nullptr){
                    left_head=left_head->next_right;
                    returnMatrix->insertElement(left_head->row,left_head->column,left_head->value);
                }
                else if(left_head->next_right== nullptr){
                    right_head=right_head->next_right;
                    returnMatrix->insertElement(right_head->row,right_head->column,right_head->value);
                }
                else{
                   if ((right_head->next_right)->column<(left_head->next_right)->column){
                       right_head=right_head->next_right;
                       returnMatrix->insertElement(right_head->row,right_head->column,right_head->value);
                    }
                   else if ((left_head->next_right)->column<(right_head->next_right)->column){
                        left_head=left_head->next_right;
                        returnMatrix->insertElement(left_head->row,left_head->column,left_head->value);
                    }
                   else{
                       left_head=left_head->next_right;
                       right_head=right_head->next_right;
                       returnMatrix->insertElement(left_head->row,left_head->column,left_head->value+right_head->value);
                   }
                }
            }
        }
        return returnMatrix;
    }
    friend SparseMatrix<T> operator+(SparseMatrix<T> right,SparseMatrix<T> left){
        SparseMatrix<T> ret=*right.addTwoMatrix(left);
        return ret;
    }

    T getElement(int row,int column){
        node<T> *tmp_head=this->head;
        for(int k=0;k<row;++k){
            tmp_head=tmp_head->next_down;
        }
        for(int k=0;k<column;k++){
            if(tmp_head->column==column){
                return tmp_head->value;
            }else if(tmp_head->next_right== nullptr) {
                std::cout << "incorect column of element";
                exit(-1);
            }else{
                tmp_head=tmp_head->next_right;
            }
        }
    }


    void deleteElement(int row,int column){
        if(row>rows||column>columns) exit(-1);
        node<T> *tmp=head;
        for(int i=0;i<row;++i){
            tmp=tmp->next_down;
        }
        for(int i=0;i<column-2;i++){
            if((tmp->next_right)->next_right== nullptr) break;
            tmp=tmp->next_right;
        }

        node<T> *nextAfterDeletedElement=(tmp->next_right)->next_right;
        node<T> *nextAfterDeletedElementDown=(tmp->next_right)->next_down;
        delete tmp->next_right;
        tmp->next_right=nextAfterDeletedElement;

        node<T> *tmp1=head;
        for(int i=0;i<column;++i){
            tmp1=tmp1->next_right;
        }
        for(int i=0;i<row-2;++i){
            if((tmp1->next_down)->next_down== nullptr)break;
            tmp1=tmp1->next_down;
        }

        tmp1->next_down=nextAfterDeletedElementDown;
    }
};



TEST(test,test){
    SparseMatrix<int> matr(4,5);
    SparseMatrix<int> matrt(4,5);
    matrt.insertElement(1,3,8);
    EXPECT_EQ(matrt.getElement(1,3),8);
    matr.insertElement(3,3,5);
    matrt.insertElement(3,3,4);

    SparseMatrix<int> mate=matrt+matr;
    EXPECT_EQ(mate.getElement(3,3),9);

}

